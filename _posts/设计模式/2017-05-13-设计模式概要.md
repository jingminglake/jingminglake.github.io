---
layout:     post
title:      设计模式概要
subtitle:   设计模式简单理解小结
date: 2017-05-13
author:     Jingming
status: publish
catalog: true
tags:
    - 设计模式
---

### 1. 工厂模式（Factory Pattern）
工厂模式是解决根据类生成对象时候由于类种类比较琐碎、比较多造成的依赖多的麻烦。也就是说解决了一系列相互依赖对象的创建工作。

工厂模式的方法就是：有一个工厂，只要你告诉工厂该对象的名字（字符串），那么工厂就会造一个该对象给你。

具体实现
简单工厂模式：类似代理。
抽象工厂模式：继承的方式，工厂是抽象的，接下来一层还有具体的工厂。
### 2. 单例模式（Singleton Pattern）
实现单例的三要素：

（1）保证唯一：则需要将各种拷贝构造函数和赋值运算符重载放入private，并在private声明一个static的对象(或者对象的指针)。

（2）提供全局的访问唯一对象的方式：getInstance()方法。

（3）只有一次定义唯一对象：在全局区定义。如果没有这次的全局区定义，则会报链接错误。
### 3. 状态模式（State Pattern）
类会含有状态，这样，只要运行时该类的对象的状态改变，那么他的行为自然发生改变，看起来好像我们更换了对象的类型。
### 4. 策略模式（Strategy Pattern）
类中某些方法会根据传入对象的不同，而进行不同的处理。与状态模式相比，更加轻量化，状态模式是整个类的切换，而策略模式只是类中一个方法的切换。
### 5. 适配器模式 (Adapter Pattern)
适配器模式是两个不兼容接口之间的桥梁，例如读卡器，网卡适配器。对应设计模式，就是使得不兼容的类或者对象之间可以一起工作。

例如：Target接口类想要调用Adaptee的request方法，但是Adaptee没有该方法。适配的方法就是建立一个中间类Adapter，里面包含了一个Adaptee的实例，并提供request接口。中间类同时implements Target类，这样生成适配器类对象后，可以使用Target来调用request接口。

适用环境：系统使用现有的类，而这些类不符合要求。建立一个重复使用的类，与以后建立的类一起合作。

运用实例：jdbc。jdbc向上层提供数据库访问接口，其实就是在原来不同数据库的操作接口的基础上，封装了一层统一的适配接口。
### 6. 代理模式（Proxy Pattern）
https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F

代理模式是一个对象调用另一个对象的时候，并不直接调用，而是通过第三方的对象来调用。
这样的好处是，第三方对象（也称代理对象）可以实现一些额外的处理逻辑，例如日志、缓存、访问控制、远程访问控制等。

静态代理：代理对象中使用的类都是先写好的。

动态代理：代理对象中使用的类对象是根据反射机制生成的，也就是工厂模式。运用实例：spring aop。
### 7. 原型模式 (Prototype Pattern)
目的是解决某些结构复杂对象的创建工作。JAVA中的可以通过重写clone()方法来拷贝自身来创建新的对象，其中一种使用方式就是实现深拷贝。
### 8. 建造者模式（Builder Pattern）

目的是在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。

https://blog.csdn.net/carson_ho/article/details/54910597

https://www.jianshu.com/p/e2a2fe3555b9

可以解决构造函数参数种类多样，不好设计的痛点。

具体实现：在被构造类A中建立final静态内部类，静态内部类的build方法负责调用A的构造方法传入一个builder对象（Builder类的this引用）返回一个A的对象。
静态类的好处是该类对象只有一个实例，final表示该类不能被继承，内部类好处是方便的让外部类、内部类互相知道类型，静态加内部的好处是内部类不依赖外部类对象，且静态内部类
并不会随着外部类的载入而被载入，只有当其内部方法被调用时才会装入JVM，这样节省了空间。

使用Builder的类不对外提供setter方法，构造方法，并使得属性是final的，这样防止对象处于不一致状态。也就是说builder生成的对象是不可变对象。

参考：https://blog.csdn.net/hikvision_java_gyh/article/details/8963562
https://blog.csdn.net/yaomingyang/article/details/79363631
https://stackoverflow.com/questions/30396203/how-to-modify-the-already-built-object-in-java-when-the-object-is-built-using-b
### 9. 外观模式 (Facade Pattern)
https://blog.csdn.net/ruizeng88/article/details/6606438

外观模式，就是抽象出高层接口，具体实现留给子层次。看起来和适配器模式区别不大，但是外观模式更加注重细节隐藏，而适配器模式更注重可移植。Facade模式里面可以由实现者来定义新的接口，而adapter只是为了满足现有接口进行封装。

个人理解：Facade模式像是在定义标准，抽象出新接口，不关心具体实现，而且很权威。
### 10. 观察者模式 (Observer Pattern)
https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html

一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。也就是一种一对多的依赖关系。也叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。
被观察的目标有观察者的对象列表，一旦观察目标发生变化，将执行notify方法通知所有观察者。
reactive programming：流对象就是目标对象，然后观察者对象可以接受流对象的信息，并做相应处理，其中处理方法使用回调，也就是自己设计。
### 11. 委托模式 (Delegation Pattern）
https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F

委托模式就是说，接收请求的对象将请求委托给另一个对象来处理。也就是说通过一种方式，一个对象可以切换自己的委托者（依赖多个委托者的组合），从而达到不同效果，也就是使用组合来代替继承。

与代理模式的区别：代理模式的接口和接收请求的对象是一致的，但是代理模式自己内部封装了逻辑，接收请求者完全不知道代理者干了什么，而委托模式下，通过切换委托者，我们大致能知道他干了什么。
### 12. 装饰器模式（Decorator Pattern）
增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。
### 13. 对象池模式 (Pool Object Pattern)
设计一个池类来对于一组对象进行管理，目的是重用这些对象。例如，池的内部分为两个组，一个组表示对象正在使用，另一组表示对象未在使用。这样，当有使用者来要求使用对象的时候，那么就可以在未使用组里拿出一个对象，供使用者使用，并加入到正在使用组，等到用户使用完该对象后，可以通知池对象，池对象就会对使用完的对象进行检查，并进行一些例如还原性的处理后，从正在使用组拿出并加入到未使用的组里面，供后来的使用者来继续申请使用。

实例：

（1）游戏中的子弹。游戏中的子弹对象显然不应该被频繁的创造和释放，可以建立池对象对子弹对象的属性进行管理，例如在子弹消失的时候，可以将子弹位置进行还原达到“回收”效果。

（2）数据库连接池。程序与数据库建立连接和释放连接都是有很大的开销的，如果简单的一次读一点数据，就创建关闭连接，再读一点就再创建释放一次，显然不可取。当然，相比于子弹这种简单的例子，数据库的连接池更加复杂庞大，例如管理的对象是按粒度分层管理的，第一层就是连接，一个连接有对应了多个的语句，也就是第二层，然后每个语句对应了不同的查询结果，作为第三层。数据库连接池系统保证了这些new出来的对象被充分的复用。
