---
layout:     post
title:      Ruby基本语法
subtitle: 笔记
date: 2020-11-26
author: Jingming
catalog: true
tags:
    - Ruby
---
### 一、区别于Java
- 任何东西都是对象，"123".object_id 返回"123"对象的hash地址，且每次返回地址不一样，因为每次输入的"123"

都被解析器当作新的对象。那如何让解析器知道是在引用之前的变量呢？使用变量符号，:var。

另外可以使用.class来查看类型。

- 方法中如果没有显示return，那么最后一条语句的值；调用方法时参数不需要使用括号。

- Ruby强制规定类中的setter方法名必须以=结尾。
Ruby对类实例变量进行赋值的时候，o.p = v，将其解释为 o.send(:p=, v)，此处可以看出'p='是一个
方法名。
- 使用module，module和class的区别是不能生成实例，但是可以通过被include的方式来实现
代码复用。module相当于namespace。
- 作为脚本语言，有命令行交互模式，按irb进入。
- 使用yield关键字作为占位符，可以将代码块传入函数，可以做回调效果。
   或者使用&block作为函数参数，表示传入一个代码块，在函数中使用block.call（）来调用代码块，或者不调也可以。
- 使用单引号的字符串表示可以包含"格式化"方式的字串（也称可以eval的字符串）；双引号的字符串则是保持原样的字符串。
- self修饰的方法是类方法。
- initialize 方法相当于Java的构造函数。
- Rails作为Ruby的Web框架，相比于Java的框架，对数据库更加的依赖，任何环境，包括开发环境，都必须
创建数据库才能运行。
- require相当于Java的import

### 二、特殊符号
| 符号       | 实例   |  实例解释  | 注意事项 |
| --------  |:-----:| :-----:| :-----:|
| ！      | foo.sort！   |   表示不是对foo对象的深拷贝进行修改，而是对foo对象做修改 |
| :       | :var        | 普通变量 | 适合作为键值对的键，因为系统保留了该变量的引用，注意:var是变量，而不是：做修饰、var做变量。
| @       | 类中 @name | 加在类中变量name前面，有this的效果，表示变量是类的一个实例变量 | 类可以不定义变量name，在类方法中仍可以使用@name|
| @@       | 类中 @@count | 加在类中变量count前面，表示count是属于类的，而不是属于类对象的 | 类必须显示定义变量count，使得count成为类变量|
| \#      | \#{变量名}  | 放在字符串""中，有格式化字符串%s的效果 |
| attr_accessor :variable_name | attr_accessor :x, :y | 给类添加两个实例变量，且给两个变量默认的带上getter和setter。理解：accessor=reader+writer | 变量名前一定要带 : ，变量名之间要用 , 分割 |
| $ | $var | 声明var是全局变量，一般写在函数和类的外面 ||
| \|\| | \[4, 6, 8, 13\].find { \|e\| e > 7 } |  结果是8， find找的是第一个满足条件的值 | 结合循环使用，e表示当前迭代器访问的元素|
| reduce(sym) → obj | (1..8).reduce(:+) | 结果是1到8的总和 | sym表示运算符号|
| reduce(initial, sym) → obj | (1..8).reduce(100, :+) | 结果是1到8的总和 + 100||
| reduce(initial) { \|memo, obj\| block } → obj| (1..8).reduce(100) { \|sum, num\| sum += num } | 结果是1到8的总和 + 100| memo表示reduce循环时候的累计迭代器（accumulator）, obj表示当前迭代器访问的元素, memo会被初始化为initial值，没有给定initial值时，会默认选择调用集合中的第一个元素作为memo值|
| * | def sample (*test) | 可变参数，也就是说test是一个大小不确定的数组||
|_| for _ in range print ('x')| _表示一个不重要的临时变量
|select|\[1,2,3,4,5,6].select(&:even?) => \[2,4,6]; \[1].select(&:even?) => \[]| 返回的是数组（或空数组）|
|collect or map| array = \["a", "b", "c"] array.map { |string| string.upcase } => \["A", "B", "C"] | 作用是对数组遍历，并将每次遍历的计算的最后一条语句结果放入结果数组，最后返回结果数组|与使用each的重大区别就在于each并没有所谓的结果数组，而是每次都返回原始数组的修改结果（类型和原始数组完全一致，而map不一定）。
|class << | class << self | 参考http://wemee.blogspot.com/2014/07/ruby-class.html 总结：class << 可以修改对象的方法定义，self的时候，相当于修改类方法||
|方法参数中使用&|def print_phrase(&block) block.call end|https://medium.com/@sologoubalex/parameter-with-ampersand-operator-in-ruby-6a6a7fd666d5|可以将块作为参数传入函数|
| proc | Proc.new{}|https://ruby-china.org/topics/10414| proc的作用是使得块实例化以便在方法间传递 |
|\_\_FILE__|\_\_FILE__|返回代码所在文件的项目路径||
|$PROGRAM_NAME or $0| $PROGRAM_NAME | 返回当前进程的命令所在路径 ||

### 三、具体使用实例

- 数组元素遍历修改
```
myarr = [{"a"=>3, "b"=>2}, {"c"=>3, "a"=>3}]
puts myarr.map {|e|
  e["a"] = 100
  e["c"] = 101
}

#output: [101, 101]

puts  myarr  

#output : [{"a"=>100, "b"=>2, "c"=>101}, {"c"=>101, "a"=>100}]
```

注意，如果使用myarr.map！，那么map本身将被修改为myarr.map！的结果，也就是每次循环最后一条语句值组成的数组，如下：

```
myarr = [{"a"=>3, "b"=>2}, {"c"=>3, "a"=>3}]
puts myarr.map! {|e|
  e["a"] = 100
  e["c"] = 101
}

#output: [101, 101]

puts myarr  

#output : [101, 101]
```

- 对象是否为空，不为空则调用其中的方法

解决方法：（1）使用 对象名.try(:方法名, :方法参数)

举例： @Person.spouse.name if @Person && @Person.spouse <=> @Person.try(:spouse).try(:name)

（2）使用 对象名.try!(:方法名, :方法参数)

和try的区别是，在对象不为空，但是没有该方法的时候，try会返回nil而try!会抛出NoMethodError异常。

（3）使用 对象名&.方法名

等价于对象名.try!(:方法名, :方法参数)

> https://apidock.com/rails/v3.2.1/Object/try <br/>
> https://devdocs.io/rails~5.1/object#method-i-try-21

- 处理嵌套的数组或哈希为空的

**解决方法**：使用dig。

例如，我们有params = { user: { choices: \["1", "3", "5"\] } }。

现在要读取里面的choices。使用params\[:user] && params\[:user]\[:choices] || \[]，

注意其中在访问choices之前，要保证user不为空，否则返回空数组。

这样在嵌套内容多的时候，会写出一堆空判断，可以使用dig，写法是：params.dig(:user, :choices) || \[]。

这个好处不明显，我们再来看一个复杂点的例子，params\[:user] && params\[:user]\[:address] && params\[:user]\[:address]\[:street] && params\[:user]\[:address]\[:street]\[:number]

如果使用dig，那么可以写为params.dig(:user, :address, :street, :number)。

再来看看数组的dig用法：array.dig(0, 1, 1) <=> array\[0]\[1]\[1]

### 四、Ruby文件组织（Rails框架）

- 冻结文件中的字符串

https://ruby-china.org/topics/35215

- 使用配置文件
使用Rails.application.config_for读取项目config目录下的yml文件。
yml文件中，支持ERB语法，说白了，就是使用标签<%= %>，这样里面可以使用Rails的复杂变量，例如ENV，是Rails
中定义的系统环境变量，来源是drakefile中的配置，可以配置path，也可以直接加入键值对。

https://www.justinweiss.com/articles/the-lesser-known-features-in-rails-4-dot-2/
