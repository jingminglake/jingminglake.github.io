---
layout:     post
title:      系统设计知识（一）
subtitle:   缓存技术
date:       2021-03-05
author:     Jingming
header-img: img/post-bg-map.jpg
catalog: true
tags:
    - 系统设计
---

参考了九章的系统设计。

### 一、系统的访问量级

了解系统的访问量级后，就可以配置相应的技术来满足要求。

关注点在于，多少用户每天进行操作，操作的种类，操作的数量，以及操作之后，系统究竟进行了哪些的耗时操作；  
另外，这些操作往往不是平摊在24小时的每一秒上，通常情况是白天比晚上忙，一天中有顶峰操作数，一般来说是平均操作  
数的三倍。

具体来说，假设日活用户是1亿(100M)，最频繁的操作种类是浏览查询，假设每天100次，那么QPS约为100k（100M * 100 / 86400）。

一般来说，Mysql/PosgreSQL技术支持1k级别，Mongodb/Cassandra支持10k级别，Redis/Memcached(内存型nosql)100k级别。

### 二、缓存技术

#### 使用缓存的原因

查询操作过程中，瓶颈往往是读写数据库的部分速度比较慢，不满意。

缓存技术就是用于解决读数据库慢的技术（不解决写技术！）。它的原理是，使用读取速度更快但量没有数据库大的存储技术，记录数据库的复制值，

这些复制值是经常被用户访问的内容，根据二八定律，这些复制值能占80%，但实际上，缓存的命中率高达95%。

PS. 缓存，不一定要使用内存或者快速存储技术，它也可以是一套系统，只要这套缓存系统的读取速度比直接读的系统快就可以（例如文件系统可以做网络的cache）。

另外，服务器为了防止Dos攻击，或者担心自己的服务器挤爆了，那么会对访问的频率做出限制，但是实际上，有些服务是不必每次都调用的，例如token服务，例如token
的有效期是一天，那么一天只需要调用一次就可以了，这样服务器干脆告诉客户端，这个是24小时有效的，因此客户端知道后，每次读取token后，就保存到本地缓存里面，
只有token过期了，那么才去再次访问服务器。

#### 缓存产品

memcached就是一种缓存技术，mem指的是内存缓存，d代表进程，也就是说memcached是一种运行在背景下的一种缓存进程，使用机制和hash表使用差不多。

redis也是一种缓存技术，它于memcached不同之处在于支持数据持久化，也就是一种cache though技术，在外界看来，redis里面包括了cache和DB，
只要访问redis即可。

#### 缓存设计模式

所谓设计模式，也就是指编码中设计时候的一些固定套路，参考多种固定套路能指导我们制定自己的套路来正确合理使用缓存满足业务需求。

场景一：读多写少的数据。例如，用户的资料信息，访问的多，但是用户不会经常更新自己的资料信息；又例如，token服务器返回的信息告诉服务器token的时效，客户端
可以缓存结果，减少访问服务器。

解：这种场景适合经典策略：懒加载，也就是先读取缓存，如果缓存中没有要的数据，就去数据库中读，然后将最新值更新到缓存中。

懒加载的边界情况考虑：如何更新缓存中的数据？例如DB中的数据更新了，而此时进程却不知道数据更新了，还是在使用缓存中的旧数据，从而发生已知或未知的错误；又例如，
缓存系统不工作了，例如连不上网了，导致其中的数据全部是旧数据。

解：如果是发生已知错误，那么一种方法是可以在错误发生时候捕获，然后进行处理：从DB中读数据并更新到缓存中，然后继续尝试一次。这种策略的缺点是，多线程的情况下（现实情况），很多线程都会由于
发生错误了，然后去读DB，然后更新缓存，这样读DB的次数仍然不少，而且还会有竞争问题race condition。
如果发生未知错误，那无解，因为很难察觉。

最佳实践方法：引入TTL技术。引入之前，缓存就像是hashmap，引入之后，cache就像是带时间的hashmap，具体来说：在cache中放入键值对的时候，会记录当前的时间（时间戳），
然后读取时候的时间已经超过TTL，那么这个键值对失效，也就是说，就当该数据没有，读取出来的键值对是空，而不是过期的数据。

这种设计默认在TTL时间内的缓存数据是合法的，这将大大减少读取旧数据的可能性，一旦数据过期那么去读取DB并更新缓存就好了。
其中一种边界情况是：如果多个线程同时发现了缓存数据过期了，都去读取DB，造成竞争问题影响效率？

解：其实ttl的好处之一就是，如果多线程中只要有一个线程成功的更新了缓存，那么其他线程在访问的时候，TTL被刷新了，因此还是能读取到正确数据。
为了避免竞争，可以新增一个竞争ttl，也就是说，如果TTL过期了，那么再去看有没有其他线程已经去更新了，如果有，那么这次就不去更新了，而是干脆返回旧数据得了，
如果旧数据造成了错误，那么就重新尝试就好了，由于重试时候的有一定的时间间隔，那么下次读的时候大概率是会读取到已经更新好了的数据。
这个所谓的竞争ttl，就是说发生竞争状态的时候，就当这个数据在缓存中多活了一会儿。


场景二：读多写多的数据，用户多、可以预见用户经常来读。例如，排行榜、推荐内容，这些都是预料到用户会来读取的且经常变化的内容。

解：这种场景下，要做的是保证在写的时候，要立即把数据同步更新到缓存中，减少用户读缓存不命中的情况。也就是经典的直写策略。

PS. cache和db是两套系统，它们需要保持一致性：保证从两套系统中读出数据是一样的（也就是保证从cache里面读出来的和数据库是一样的、因为先读cache）。
多线程（之前的刚从缓存删除，另一个线程就把旧数据写回来）和down机情况都会带来不一致的问题。

#### 实战考虑

为什么要使用 database.set(user); cache.delete(key);？

1. 多线程的情况下，不加锁的情况下，无论代码顺序是什么，一致性都有可能被打破。而缓存技术恰不能加锁，因为加锁效率太低，得不偿失。

2. 代码中，前一条语句如果失败，后面的语句是不会执行的。
两条语句：如果第一条就直接失败，那么不会影响系统，因为第一条的结果不会保存，而且后面语句不会执行（操作失败直接返回）；
如果第一条成功，第二条失败，那么就会有不一致的问题。
因此，要把相对容易失败的语句写在前面，把不容易失败的语句写在后面。
实际上，缓存技术相对于数据库技术来说是出错率较小的，因为采用的是缓存是基于明确的哈希技术。