---
layout:     post
title:      Leetcode按题目类型总结（二）
subtitle:   双指针
date: 2017-09-25 00:14
author:     Jingming
status: public
catalog: true
tags:
    - Leetcode
    - 算法
    - 数据结构
---
> 所有代码详见：https://github.com/jingminglake/Leetcode

# 总体思路
- 同向双指针
1. 解决滑动窗口类（连续子数组）的问题

滑动窗口问题，首先看窗口是不是固定大小的。

（1）如果是固定大小为k的窗口，那么这样的窗口在大小为N的数组有N-k+1个（理解：考虑滑动窗口的起点，只能是从下标0开始到下标N-k结束）。对于这种固定大小的窗口，一般题目的描述就是连续k个，此时要想办法把这种连续k个使用数组这样的结构表示出来，然后就可以使用同向双指针。时间复杂度：首先构造k大小窗口使用k时间，然后每次移动窗口，一共移动N-k次，所以花费N-k时间，加起来知道固定大小滑动窗口时间复杂度是O（N）。

（2）如果窗口大小不固定，例如找出符合某个特征的substring（连续子数组）。这种连续子数组在数组中有N^2个（N个点任选两个点组合就可以成为一个连续子数组），所以双重循环暴力求解情况下，时间复杂度是O（N^2）。
使用同向双指针的好处就是减少双重循环中的一些废操作，只保留精华部分，使时间复杂度由O（N^2）到O（N）。 比如，一开始只使用right向右走，某个时刻窗口从合法变到不合法了（如果是从不合法到合法，那么要看题目要求是不是求最短合法的），那停止right移动，此时只需要移动left。这样，每次left和right都会至少移动一个，而left和right最多一起移动2N次，而每次移动花费时间1，所以时间复杂度是O（2N）。
编码模板就是：right小于总长度的情况下（因为窗口的右侧不能越界，左侧是一定不越界的），如果right向右走之后仍然满足性质条件，那就继续移动right，否则就缩减窗口，也就是移动left。

PS. 连续子数组常用技巧就是先求前缀数组。

2. 找两个点

方法就是左指针记录扫描过的某个特征的点，右指针扫描，然后每次减去左指针记录的指来得出答案的候选者，花费O（N）时间。
双指针的题目理解题很关键，题意中暗含很多特征细节决定如何正确使用双指针。
# 具体题目
### 406(lintcode)和大于S的最小子数组
**题意**：数组中的元素都是正整数，求和大于S且最短的substring。

**解**：由于数组中的数都是正数，所以才能考虑使用滑动窗口双指针。因为多加一个元素就会有一个增长的趋势，否则，如果是负数的，那么就没有增长趋势，也就是说窗口如何移动是不确定的。
使用同向双指针，增大窗口，只要窗口的和大于等于s，那么就统计下长度，然后从左侧减小窗口的长度。

### 283. Move Zeroes
**题意**：包含0的数组，将0移到最后面，注意非0必须保持原序（0不需要有序）。

**解**：使用同向双指针，类似于快排中按pivot分成两半的过程，这里的pivot就是0，不同的是不止一个0。
left指针指向放入下一个非0的空格的位置，right指针进行扫描，目的是找到所有的非0数，然后顺序放入left指向的位置。
具体：如果right遇到0，那么只++right。否则，如果right遇到非0，那么看left当前是否指向0，如果left是0，那么就swap并left++，right++。如果left不是0，那么可能有两种情况，一种是left和right指向同一个元素，另一种是指向不同非0元素，假设该数组里面没有0，那么第二种情况不存在，反之，如果有0，那么0之前的连续非0部分的处理是不存在第二种情况的（全是第一种情况），之后left会等在这个地方0这个地方，此后left会一直指着这个0，所以第二种情况还是不会出现，因此第二种情况不存在。
所以，同一写成，发现right指向非0，那么就先swap left和right指向的元素，然后left和right都++。

### 75. Sort Colors
**题意**：数组里面只有三种数：0，1，2。现在要排序。不能使用counting sort，只能扫描数组一遍。

**解**：双指针。此题与只把0，1分开的那种pivot分两半过程的区别是，需要分为三半。
方法一：先根据0分两半，在把1和2分两半。不过需要遍历两遍。

方法二：只需要遍历一遍。使用双向双指针+一个扫描指针，left保证left左边的为全0，right保证其右边的为全2。扫描指针扫描一遍后，所有的1将被挤在中间。

交换的时候，当前指针i如果指向的是0，那么与left交换，left++，同时当前指针前进一位，因为当前指针始终在left的右边，说明left指向的部分已经被处理过了，所以被left交换到当前指针的元素不可能是2，而只可能是0或1，所以可以让i++。

与右边交换的时候，由于被交换过来的值不清楚，因此此时不能移动i，继续处理一遍i。

### 15. 3Sum
3Sum解题思路是：对数组中每一个数，把除了该数以外的数，当作解决一个2Sum的问题。

2Sum的一个解法中使用了hash表，如果3Sum中仍然使用hash表，那么3Sum的时间复杂度是O（n^2)，空间复杂度是O(n)。 如果考虑到最少要O（n^2)的时间复杂度，那么我们可以先排序，然后在2Sum中使用双指针的方法，那么空间复杂度降到O（1）。
注意：去除重复的问题基本都不会是计算完了再去，而一般都是一边计算，一边去除。
如何去重：（1）对数组先排序，然后对每一个数遍历的时候，如果该数和上次遍历的数相同，那么不计算了。这样去除了相同元素重复计算的问题。

（2）遍历每个元素的时候，只需要对该元素之后的元素使用2Sum，而在之前使用的元素不需要考虑。理解：每个元素遍历的时候，前面的元素已经都考虑过自己了，如果自己还考虑前面，那么重复了。

（3）计算2Sum的时候，不止有一个解，而且有些解是重复的，必须去除。去除方法是在找到一个解的时候，left向右看，有没有和当前left指向的元素相等的元素，如果有，那么直接left++，直到找到一个不相等的为止。对right进行类似操作。

### 259. 3Sum Smaller
**题意**：整数数组，寻找三个元素和小于target的情况总数。

**解**：暴力求解显然是O（N^3）。此题优化技巧在于，在固定一个坐标的情况下，另外两个坐标的所有情况的寻找是否可以是O(N)时间，而不再是O（N^2）的时间。怎么优化双重循环暴力解呢，双指针。 
技巧在于可以先排序。然后使用双指针。先考虑同向双指针，也就是先固定left，然后right遍历，到达某个right时候，和已经大于target了，那么之后的right就不合法了，那么此时让left++，发现没有意义。使用双向双指针，如果一开始left和right指向的值加起来就比target小，说明所有的以left指向的数为其中之一的组合都比target小，此时将这些组合数纪录下并移动left；反之，如果大于等于target，那么此时left不能移动，因为此left和之后的一些元素配合可能是答案，不能丢失掉，而移动right是没有这样的顾虑的，因为此right和任意的其他元素搭配必然超过target。这样双指针O（N）的时间内就能求出这种两坐标的组合数。

### 42. Trapping Rain Water
**题意**：二维的坐标上有一些柱子（高度保存在数组中），求能收集的雨水的总量。第一个柱子和最后一个柱子存不了水。

**解**：发现每个柱子自己能积水的高度取决于其左侧最高柱子和右侧最高柱子两者中较矮的那个，使用暴力求解，对每个柱子向左右扫描，消耗时间O（N^2）。
如果有办法O（1）时间知道一个柱子左右两边最高的柱子，那么就可以把复杂度降到O（N）。
方法一：可以使用两遍扫描方法，每次扫描记录下每个元素的左右侧最高柱子高度，但这样需要花费O（N）空间。

方法二：使用双向双指针，分别指向数组两侧，往中间扫描，扫描的时候，使用两个变量记录扫描过的访问过的柱子里最高的左侧柱子LM和右侧柱子RM。中间的柱子在什么时候知道能收集多少雨水呢？考虑两个指针当前指向的柱子高度，首先知道，两个柱子灌水的高度上限就是LM和RM里面较矮的一个，对于其中靠近较矮柱子Hmin的柱子当前高度h如果比Hmin要大，那么该柱子无法储水，因为一定会从Hmin那一侧流掉，相反，如果h比Hmin小，那么它一定能储水（理解：因为左右两侧都发现了比自己高的柱子），且储水高度一定是h-Hmin。同理，考虑其中靠近较高柱子Hmax的柱子，如果当前高度h如果比Hmin要大，那么该柱子无法储水，反之，不一定，还是得看h与Hmin的比较。
因此，扫描的时候，移动较靠近Hmax的柱子没有意义，而需要每次移动靠近Hmin的那个柱子，并记录该柱子的储水值。注意移动过程中，随时需要更新Hmin和Hmax，可以决定下一次移动那一侧的指针。

### 407. Trapping Rain Water II
**题意**：基于42题，不过这次是三维空间上的收集雨水。

**解**：经过42题的分析我们知道，每个柱子能否有积水要看周围是否存在一整圈比自己高的柱子把自己包围住，且存储水的量取决于这些高柱子中最矮的那个。
因此扫描起点就是矩阵的外框。从外框向中间扫描的过程中，同42题的分析，要从离外框中最矮的柱子的柱子开始进行访问，因为它的结果是可以立即知道的。为了找到外框中最矮的柱子，可以使用优先级队列。之后，找到该柱子一个最近的邻居点访问（上下左右四个方向），该邻居点一定不能是之前访问过的结点（建立一个hash表，标记访问过的结点）。
也就是说，整个扫描过程是类似BFS，但是使用的是优先级队列。

### 443. String Compression
**题意**：{"a","a","b","b","c","c","c"} 压缩成{"a","2","b","2","c","3"}，要求是O（1）空间。

**解**：此题的压缩方法是将字母重复出现的次数写在后面。难点是考虑边界：例如{"a","b","b","b","b","b","b","b","b","b","b","b","b"} -> {"a","b","1","2"}。
要使用之前的数组空间（因为是压缩的，足够了），使用双指针，一个last指针指向要加入压缩后数组的新位置。然后，扫描，如果当前字符后面有相同的字符，那么新建循环(要新建！)将后面相同的字符吃掉，然后将数字加入压缩后的新位置。由于last指针要指向新数组的最后位置，所以要避免last = i的这种操作, 所以进行压缩的条件并不是last和i进行比较，而是i和i+1进行比较。
此题的启发：对关键信息进行下标锚定，例如此题就是对新出现的字符作为起点，与其后一个的字母进行比较的过程，其中需要单独处理没有后一个字母，也就是字母本身是最后一个字母的特殊情况。

PS. 字母出现一次，后面不能加1，因为可能会变更大。

### 532. K-diff Pairs in an Array
**题意**：给出一个k，求出数组（里面是整数）中差距为（相减的绝对值）k的数量。其中要求pair是不重复的，不是下标不重复，而是数字不重复，(i, j) 和 (j, i)算重复。

**解**： 难点在于去重。2sum的边扫描边存储的hash方法是不行的，因为那种属于下标不重复。
方法一：双指针。先排序，left和right指向0和1，left不能等于right（在left等于right的时候，right++），然后看双指针指向时候的差别，如果差别为k，那么res+1，left+1，然后看left是否和前一个left相等，如果相等要跳过（循环）。

方法二：hash。将每个元素存入hash，记录每个元素的数量，然后遍历，看与其差值为k的元素存不存在即可。

细节：（1）由于使用hash是无序的，所以只需要判断比元素大k（k是绝对值，不可能为负，需要在一开始判断）的元素的存在（数量不重要），不需要计算小，否则计算出的是双倍的。

（2）k为0时候，需要看该元素是否出现两次以上，如果出现，那么就多了一种pair。

### 640. Solve the Equation
**题意**：解等式。

**解**：双指针，一个指向数字的开始，另一个从左到右扫描。如果遇到各种符号（遇到等号，那么后面的操作是反着的），例如遇到x，那么将前面的数字取出来，做一个系数计算。如果遇到的是加号减号，那么是计算常数的总和。

### 15. 3Sum
**题意**：找出数组中不重复的三元组，和为0。

**解**：相当于对除掉一个数之外的数求2Sum。但是不一样的地方在于结果不止有一个，而且存在大量重复。所以使用双指针操作起来更加方便，可以跳过下一个相同的数字，不在计算。
有两处需要去重：第一处是对于当前扫描元素，第二处是对于处理元素扫描时候，要去掉重复的。

### 3. Longest Substring Without Repeating Characters
**题意**：求substring中不含重复字母的最长的那个。

**解**：双指针维持一个窗口，窗口内是不重复的串。left和right指向最长不重复字母的开头和结尾，然后right++，先判断right是不是遇到一个重复字母，如果是，那么left跳到该重复字母（hash表中字母出现下标要时刻更新为最靠近right的）的下一个位置。然后新窗口继续扩张，一边扩张，一边看是否能更新最大值。

维持一个hash表，遇到重复字母时候该字符落在left右边（也就是比left大），此时需要更新left。

然后不断更新当前right指向的字母的下标为right就可以了。
### 680. Valid Palindrome II
**题意**：验证回文串，不过允许一个字符的差异，完美的回文串也行。

**解**：此题的第一反应是对每一个元素考虑去除掉剩下的进行验证，看是否回文，而且看本身是否回文。但是此解法时间复杂度为O(N^2)。

时间复杂度O(N)的算法如下：从两边向中间做正常的验证回文串的操作，但对失配的字符有容忍，例如在i和j处失配，那么如果去掉该字符后也回文，那么i+1处到j处一定回文，或者i到j-1一定回文，满足一个即可，都不满足那就不是回文串。
### 481. Magical String
**题意**：对于魔数，要求前i位的魔数中含有多少个1。所谓魔数，就是满足：
（1）只含1，2

（2）连续的1和连续的2切开来看，数量是魔数本身。

例如：1 22 11 2 1 22 1 22 11 2 11 22， 对应1 2 2 1 1 2 1 2 2 1 2 2…

**解**：使用双指针，我们构造前i个魔数。构造技巧就是，我们构造的魔数中必然含有下一个魔数的信息，也就是说，我们构造1 22 11 2 1 22 1 22 11 2 11 22这种串，而这种串中蕴含了1 2 2 1 1 2 1 2 2 1 2 2…，我们根据1 2 2 1 1 2 1 2 2 1 2 2来构造1 22 11 2 1 22 1 22 11 2 11 22。
也就是说，双指针的其中一个指针t指向构造的魔数的尾部，另一个p指向下一个构造信息。
注意起始魔数是1 2 2，后面的可以根据规律推测。
实际示范：一开始给出1 22（第一个1表示1，第一个2表示22， 第二个2表示后面应该是两个数11或22）， 双指针p，t都指向第2个2，现在我们根据p指向的2进行构造：首先，指向2代表下一个连续的数量是2，但是是11还是22呢？这要看t指针指向的结尾是2还是1了，此时是2，所以是11，否则就是22。

### 487. Max Consecutive Ones II
**题意**：01串，只能翻转一个0到1，求最大连续1的长度。

**解**：第一反应居然是动态规划，但是动态规划会明显的多次扫描和消耗空间，而此题followup暗示是扫描一次就可以解决。
此题可以使用双指针来解。显然，此题只能使用同向双指针，也就是滑动窗口。更加通用的情况下，我们使用的滑动窗口可以包容k个0转1。右指针扩充的过程中，遇到0，那么使用掉一个0转1的机会，如果全部用完，那么统计当前窗口长度。之后左指针开始扩展，窗口收缩，如果左指针指向的是0，那么说明恢复一个0转1的机会，左指针停下，右指针又可以开始扩展了。

这种方法左指针访问了数组中之前的一个下标，但是followup是一个输入流，所以需要稍微做修改，修改的方法就是采用queue来存储之前访问的‘0’的位置，之后就可以从queue的头知道左指针该跳到哪一个位置了。
不能完全理解为什么使用同向双指针滑动窗口，就能解决这个问题，也许原因之一是滑动窗口从理论上包含了全部的解空间吧。

### 264. Ugly Number II
**题意**：计算第n个丑数，定义丑数为只能由2，3，5乘构造成。规定1是丑数。

**解**：此题解题思路就是由2，3，5依次的构造下一个丑数，得出第n个丑数。
构造规律如下：对于每个新生成的丑数，有三种可能扩充的情况：分别是乘2，乘3，乘5。
我们知道前5个丑数是：1，2，3，4，5，观察下面丑数生成的三个候选序列，下一个丑数一定是三个列表中生成出来的，也就是每一列的最小值：
(1) 1x2,  2x2, 2x2, 3x2, 3x2, 4x2, 5x2...

(2) 1x3,  1x3, 2x3, 2x3, 2x3, 3x3, 3x3...

(3) 1x5,  1x5, 1x5, 1x5, 2x5, 2x5, 2x5...

更新规律就是，三个序列中每次选出最小的数，然后，由于对于1来说，三种选择（乘2，乘3，乘5）消耗掉了一个，接下来就要使用最新生成的丑数2的三种扩充的一种来填补，也就是把第一个序列更新成2x2。也就是说三个序列的安排是：第一个序列负责放所有的从0开始的丑数乘以2的扩充，第二个序列是负责放所有的从0开始的丑数乘以3的扩充，第三个序列是负责放所有的从0开始的丑数乘以5的扩充。
使用优先级序列的方法就是：保存每次的候选值，该值来自哪个最新的候选者，以及乘2还是3，还是5。
每次选择序列头的最小值，然后更新序列头，如果两个序列头相等，那么两个一起更新，因为不存在两个丑数一样的，保留一个没有意义。

dp解法的理解：对于最新的丑数序列，保持三个指针，一开始都指向第一个丑数0，第一个表示该位置的丑数只可以乘2，第二个表示只可以乘3，第三个表示只可以乘5，一旦该位置的乘x被使用过，那么说明指针要移动了，移动到下一个生成的丑数。也就是说指针指向的下标是最近可用的乘以x的丑数。

还有一点要注意：会有重复的候选者，解决方法之一是使用set去重，更好的方法是在出队列的时候，把和队列顶部相等的元素一起出了。

### 313. Super Ugly Number
**题意**：计算第n个超级丑数，超级丑数的定义是构成超级丑数的所有素数都在给定的素数列表中。1直接算一个超级丑数。

**解**：此题与丑数2解法一模一样，但是序列的个数是prime数组的大小，所以也就是k个序列的合并，在k个数中快速的找到最小值，可以使用priorityQueue。总体时间复杂度降为O(logk * n)。

### 522. Longest Uncommon Subsequence II
**题意**：与I相比，此题给出的字符串不止一个。LUS的定义: 不是其他任何字符串的子序列中最长的那个。
这也意味着LUS不一定存在。

**解**：对于I，解法就是返回两个字符串中最长那个，对于多个字符串是不是指最长的那个字符串呢？是的，不过最长的字符串有可能有两个，两个一样的字符串不能作为结果。然后，目标只能是次长的串了，次长的且唯一的串一定就是答案吗？也不是，因为次长且唯一的串，有可能是之前最长串而且不是答案串的子串，在这种情况下，违反LUS的定义，不能作为答案。
所以，正确做法就是，先将给定字符串按长度从大到小排序(相等长度串按字符串大小排序)，然后从最长串开始看，看是不是与排在自己后面的串长度一样且自己在不在集合中，如果是，那么将自己加入集合，继续计算，之后一旦出现长度不一样，且自己不在集合中的情况，那么就开始与集合中每个串进行比较，看自己是不是其中一个串的子序列，如果是，那么直接退出，说明自己不是答案，如果全都不是，那么就返回自己作为答案。
暴力看一个串是不是另一个串的子序列使用就是直接用指针指向两个串的头，如果不等，那么移动大串的指针，两两比较，如果最后小串的指针到达末尾，说明是子序列，否则不是。
### 360. Sort Transformed Array
**题意**：给出一个已排序整数的序列，然后给出一个一元二次方程，将整数带入方程，求计算结果重新的排序，要求时间复杂度为O(n)。

**解**：此题要求O(n)时间复杂度，但是没有要求空间复杂度，因此可以考虑归并排序。回想一元二次方程的性质，在a > 0的时候，曲线是开口向上的，而给我们的序列是有序的，所以，如果可以想到双指针，那将可以解了，使用双指针指向序列的头尾，那么我们知道，两个指针向中间走，都是递减的（如果a < 0，那么就是递增的），因此可以使用归并排序。
如果a == 0,那么说明整个序列是线性的，仍会维持单增或者单减性质，所以不会影响归并排序。

### 524. Longest Word in Dictionary through Deleting
**题意**: 给出一个串S和单词字典d，求字典中通过S删除字符可以得到的最长的一个单词，如果长度一样，那么返回字典序最小的那个。

**解**：此题的删字母就是噱头，实际上能不能删除得到，就是看单词是不是串S的子序列，使用双指针方法就可以了。然后此题属于暴力解，先将字典排序（长的排前面，一样长的按字典序排），然后一个个看是不是子序列，返回就可以，这种做法需要先排序。
还有一种方法就是直接一遍扫描，保留当前的满足条件的最大值作为结果，看后面能不能更新这个结果。

### 159. Longest Substring with At Most Two Distinct Characters
**题意**：求字符串S的只含两个独特字符的子串中最长的那个。

**解**：此题使用滑动窗口，如果一直处于只含两个字符，那么窗口可以一直增大，如果遇到第三个特殊字符时候，那么需要把之前一个特殊字符给删除。
方法一：使用hashmap，记录字符和字符出现的次数，right不能扩展的时候，把left增加，然后看left字符在map中次数是不是减成了0，如果不是，那么继续移动left，否则就将left对应的字符删除。这样处理，直到map中的字符数量少于2个。

方法二：使用hashmap记录字符和当前字符出现的最靠右的下标，这样删除之前特殊字符的时候，可以先扫描一遍hashmap，然后取出其中最小的，然后更新left到它的下一个位置就可以了。

### 340. Longest Substring with At Most K Distinct Characters
**题意**：与159一样，不过是k个特殊字符。

**解**：此题和159解法相同，只不过2写成k，而且k要注意是不是0，0的话直接返回。
每次找hash表中最靠左边的那个(leftMost)，删除掉该字符s\[leftMost]，滑动窗口的left指针更新为leftMost+1。

### 287. Find the Duplicate Number
**题意**：一个n大小数组中存放1到n的整数，保证其中一定蕴含一些重复的数。要求重复的是哪个数字，要求时间复杂度O(n^2)以内，空间复杂度O(1)。

**解**：此题重复的数不止一个，所以不能使用异或技巧。难点在于只能使用O(1)空间，所以不能使用hash。
此题解法一个是排序，排完然后扫描一遍，看相邻是否出现相等就可以了。
另一个解法是把整个结构当作一个链表来看，下标到值，值作为下标在继续，这样此题就变成了证明链表是否存在环了，重复的值就是环的开始点。解法是快慢指针，先找到交叉点，然后快指针指向头变慢指针，最终走到一个公共点就是重复数字。相当于142题。
注意：一开始快慢指针都要指向开头，这样判断条件就要写着while循环里面。

### 838. Push Dominoes
**题意**：推多骨诺米牌，左右推，求最终状态。

**解**：此题难点就是分析各种情况。对每个骨牌分别考虑，其实发现，影响这个骨牌的只有离他最近的左边的L和右边的R，其余的对他不能有任何影响，接下来，看左边最近的L和右边最近的R到底哪个里的比较近，那就是最终倒向哪一边，如果相同，那么骨牌就是竖立的。
这样，就有一个bfs的思路，先计算出所有骨牌最近的左侧L和右侧R，然后，最终扫描一遍得出答案。
这种方法时间复杂度是O(n)，空间复杂度也是O(n)。也可以直接从左向右扫描得出骨牌最近的左侧L，和从右向左扫描得出骨牌最近的右侧R。

优化的方法是使用同向双指针，可以减少空间复杂度。具体方法就是，用双指针指向每一对'L'或'R'字符的窗口。然后根据格子情况去一一对应处理。例如：.L.R...LR..L..中，需要看成L.R,  R...L, LR, R..L来处理，为了处理边界情况，可以一开始在开头加入L，在结尾加R。多计算两对。
双指针指的方式是这样的：对于LRLRL，left从0到n-2，right从1到n-1。找到新left之后，马上找下一个right。

### 243. Shortest Word Distance
**题意**：给出words单词数组，然后给出在单词数组里面的两个单词word1和word2，求word1和word2出现的最小下标距离，此题word1不等于word2。

**解**：word1和word2出现的下标可以组成自己的小数组，其中下标相邻的才可以进行计算，得出一个距离。
方法一：使用一遍扫描，扫描时候保持两个指针，一个指向之前访问的，表示是word1还是word2，然后，在当前指针扫描时候遇到与之前相反的情况，
那么就进行计算距离，最后得出一个最小距离返回。时间复杂度O(N)，空间复杂度O(1)。
方法二：使用两个hashmap(word1 -> vector<int>)，分别记录下word1和word2的下标数组，然后计算两个数组间相邻数的差距，具体方法就是使用两个指针分别指向
两个数组的开头，然后每次移动其中较小的，因为移动较大的必然不是words中相邻的，相反，移动较小的，两个指针指向的还是words中相邻的。每次计算出差距，直到两个
数组都访问完为止。空间复杂度O(word1数量+word2数量)，但是时间也下降到O(word1数量+word2数量)，虽然最坏情况下word1数量+word2数量也是words长度N。


### 244. Shortest Word Distance II
**题意**：与243的区别是，此题要求写成类的形式，words数组作为类的参数传入。

**解**：此题相比较243题在于，空间本来就要O(n)，所以减小时间复杂度是首要考虑的点，使用243的方法二即可。

### 245. Shortest Word Distance III
**题意**：与243的区别是，此题word1和word2可以相等，但是不是当作0距离，而是要计算真正存在的两个单词。

**解**：此题相比较243题在于，一开始先判断单词是否相等，如果相等，那么单独处理，也是比较临近单词。



### 675.

### 1229. Meeting Scheduler
**题意**：两个人，每个人给出自己的开会可用的时间段数组（时间段用整数区间表示），另外，还给出两个人这次开会的时间长度d。
现在要求这两个人的这次开会的可行时间段中最早的。

**解**：此题如果暴力求解，也就是把区间进行两两比较，在维持一个最早区间候选者，那么时间复杂度显然是O(N^2)。

可以使用常见的技巧，也就是双指针技巧来优化这种双层循环的问题。显然，可以对两个区间分别进行排序。
其中越早的区间匹配了，那么可以提前返回了。例如，首先将区间根据起点排序。然后两个区间数组的第一个s1\[0]和s2\[0]进行比较：
如果它们有交集，且交集时间大于d，那么就是可以作为结果返回了；如果不满足条件，那么画出可能的三种情况（固定一个起点小的，然后扩充另一个），
发现，其中结束点小的区间无法在配合任何区间组成结果了，因为对他来说最优的就是当前比较的区间，此时就移动这个数组的下标。
这样时间复杂度就减到了O(NLogN)。


PS.此题最有意思的地方就在于，一般题目的双指针是每次交替移动其中一个指针的一个位置，而此题则不一定，是每次移动满足条件的指针的一个位置，
时间复杂度仍是O(M+N)。

### 1099. Two Sum Less Than K
**题意**：整数数组A里面找出最小的一对，大小加起来小于给出的target。

**解**：先排序。之后此题解空间是一个二维矩阵，只考虑其中的一半（横坐标小于纵坐标的一半）。

然后对于其中，选择一个i = 0，j = len - 1为起点，特点是往左走变小，往右走变大。这样最多走len次就能得出答案。
遍历时候，选择其中的比K值小的值中最大的值作为答案即可。