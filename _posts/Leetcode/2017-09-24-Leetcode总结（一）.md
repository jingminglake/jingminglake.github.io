---
layout:     post
title:      Leetcode按题目类型总结（一）
subtitle:   数组和字符串
date:       2017-09-24
author:     Jingming
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Leetcode
    - 算法
    - 数据结构
--- 

> 所有代码详见：https://github.com/jingminglake/Leetcode

# 总体思路
数组的题目第一反应就是能不能用双指针或者hash来做，实在不行就暴力求解，看看暴力求解能否使用动态规划优化。
字符串省空间技巧：还是用原来字符串，但是使用新的下标，表示修改后的index。
subsequence：子序列，注意的是子序列中顺序还是和母序列一致(occur in order)，这点一定要考虑到。
# 具体题目
### 48. Rotate Image
**题意**： 使用O（1）的空间来将矩阵顺时针旋转90度。

**解**：由于使用O（1）的空间，那么使用交换的策略，试着将矩阵沿着i，j相等的对角线两两交换，发现结果与想要的结果之间列的顺序是颠倒的。
列调整顺序不好实现，但是行调整顺序是容易实现的。所以解法是先将矩阵行逆序，然后沿着i，j相等的对角线两两交换。
### 121. Best Time to Buy and Sell Stock
**题意**：在数组中，只能买卖各一次，求最大差值。

**解**：从左到右的遍历，自然而然就模拟买卖。维持一个值保存最小值，每次遇到比最小值大的数，就计算更新差值，如果遇到比最小值小的数，那么更新最小值。这样保证了，每个大值总是减去他左侧的最小值。
### 122. Best Time to Buy and Sell Stock II
**题意**：在数组中，买卖不限次数，求最大利润。

**解**：此题一开始以为要找到波峰波谷，即极大值和极小值，然后累积之间的差。其实不需要，举个例子：1，4，8。不一定需要找到1和8，然后8-1。可以改为发现4比1大，就计算4-1，发现8比4大，就计算8-4，然后4-1+8-4就等于8-1。
### 123. Best Time to Buy and Sell Stock III
**题意**：是在数组中，买卖两次，求最大利润。

**解**：此题变为动态规划题，有四种状态，sell1，buy1，sell2，buy2。之间相互转化关系是：
sell1 = max (sell1, buy1 + price);
buy1 = max (buy1, -price);
sell2 = max (sell2, buy2 + price);
buy2 = max (buy2, sell1 - price);
对数组循环，初始化buy1和buy2是INT_MIN，sell1和sell2为0，循环之后，sell2就是要求的结果。
### 188. Best Time to Buy and Sell Stock IV
**题意**：在数组中，买卖k次，求最大利润。

**解**：此题是动态规划，如果买卖次数大于数组一半，那么相当于第二题。如果小于数组一半，那么相当于第三题的通用情况。
使用sell[i][j]表示第i天时候是卖出状态的，并进行j次交易的最大利润；buy[i][j]表示总体的i天内进行j次交易的最大利润。有关系式：buy[i][j] = max(sell[i][j], buy[i - 1][j])；很好理解，要不就是最后一天卖出最大，要不就是最后一天不操作。第二个关系式：
sell[i][j] = max (buy[i-1][j-1] + max(0, diff), sell[i-1][j] + diff)。diff是指prices[i + 1] - prices[i]。意思是要么局部连卖两次（也就是第二题的技巧）最大，要么之前全局最优在加卖最后一个（能卖的话）。
编码时候，可以使用滚动数组将二维空间优化到一维空间，注意i和j都是依赖i-1,j-1的，所以滚动数组使用技巧就是：去除公式中的i维，然后在双重循环的第二重循环中，j应该改为从大到小，然后循环体要注意不能把之前的值给更新掉。
### 56. Merge Intervals
**题意**：合并区间。

**解**：先将所有区间按区间的左端点排序。然后，这样，相邻两个区间只存在三种情况：例如：（1，4）和（5，6）； （1，4）和 （3，5）； （1，4）和（2，3）。我们发现后两种是属于可以合并的情况。
此题解法的技巧在于，先确定每个合并之后的左端点，右端点可以先设置一个，然后，在后面的遍历过程中更新，一旦不能更新，说明出现第二个区间了，此时将下一个区间加入答案做最新区间，然后，继续扫描更新最新区间的右端点。
如果是使用left和right来保存每次的新区间的做法，那么最后出循环的时候，要把最新结果加入答案，因为在循环体中很难做到。
### 697. Degree of an Array
**题意**：求和数组的度相等的最小连续数组的大小。数组的度是指数组中众数的多少，注意的是众数可能不止一个，众数可以有多个，大小不一样，但是数量是一样的。

**解**：发现答案就是在其中一个众数为边界的子数组中。
方法是双hash表，一个表记录数组元素的个数，另一个记录相同元素的最大跨度。
一遍扫描数组后，得出数组的度以及相同元素间的最大跨度，第二次扫描，找出与数组度相等的众数元素里跨度最小值即可。
### 686. Repeated String Match
**题意**：重复扩充字符串A，看是否可以包含另一个字符串B。

**解**：扩充字符串A，直到A的长度不小于B，然后看是否能包含，如果不能包含，再继续扩充一次，再看看是否包含，如果还不能包含，那就不可能能包含。
### 459. Repeated Substring Pattern
**题意**：是判断字符串s是否是自己一个子串t的重复。

**解**：没有什么技巧，使用暴力求解就好，考虑子串的长度为1，2，...size/2。
然后使用substring来取出每一段的子串，然后比较就好。边界条件比较复杂，易出错，需要多练习。
### 119. Pascal's Triangle II
**题意**：求杨辉三角的第k行。

**解**：我们知道杨辉三角的从上到下的每行分别是: (1), (1,1), (1,2,1), (1,3,3,1), (1,4,6,4,1)...
例如我们求第4行，我们把前4行扩充成：(1,1,1,1), (1,1,1,1), (1,2,1,1), (1,3,3,1)
也就是说，只有后面3，4两行需要修改，修改的过程是：例如第3行，那么从第2个元素（3-1）开始往前到第1个元素之前，每一个元素都等于前一个元素加自己。第4行就是第3个（4-1得出的）元素到第1个元素，每一个元素都等于前一个元素加自己。
### 238. Product of Array Except Self
**题意**：修改数组：对于每个元素，修改为除了该元素外其余元素的乘积，且不准使用除法，以及空间复杂度要求为O（n）。

**解**：对于每个元素，除他以外的乘积其实分为两个部分：一个部分是左边元素的乘积，另一个部分是右边元素的乘积。所以，可以建立一个左侧累乘数组和右侧累乘数组。这样保证了O（n）的时间复杂度。如果要减少些空间使用，可以只使用一个左侧累乘数组，右侧累乘数组可以改为使用一个变量保存当前的累乘，辅助当前元素得出最终结果即可。
### 186. Reverse Words in a String II
**题意**：是翻转一个字符数组，里面的单词得还原到正常单词。

**解**：先翻转。然后，双指针，一个指针指向新单词开头，另一个扫描。一扫描到空格，就将空格前的部分翻转，并更新第一个指针到新单词的开头。边界条件是，语句中只有一个单词的时候遇不到空格。如果第一个指针仍为0，那么将整个语句再翻转一遍即可。
### 151. Reverse Words in a String
此题大意是翻转一个字符串，里面的单词得还原到正常单词。此题麻烦之处在于，各种开头空格，中间空格，都得完美翻转，也就是说，要删除开头结尾多余的空格，中间的空格也只能留一个。
解法：先整个翻转。然后，双指针，一个指针start指向新单词开头，另一个扫描。一扫描到非空格，看start是否等于0，如果等于0，说明当前扫描的是第一个单词，那么不用增加空格，如果不为0，那么start先加1，并把当前位置置为空格表示插入了一个空格。
在结束后，还要将start之后的部分（都是空格）切除掉。
方法二：使用istringstream。
### 8. String to Integer (atoi)
**题意**：实现atoi，atoi输入的串，例如： “   ＋0012a123  ” 都是合法的，结果为12。

**解**：判断输入串的合法性是不现实的，所以，正确做法是，用一个指针进行扫描。扫描前，先把前面空格吃掉，然后，在后面一步步累加数的时候，每加一个字符，先判断是否是数，如果是数，那么累加数，然后判断当前结果是否超过了INT_MAX和INT_MIN，如果超过了就返回相应最大值。如果不是数字，那么返回最新值即可。
### 553. Optimal Division
**题意**：X1/X2/X3/../Xn中加入括号，让整体值最大。

**解**：此题关键在于理解X1/(X2/X3/../Xn)就是答案。因为除法之间是有先后顺序的，也就是没有结合律的。观察可知X1必作为分子，X2必作为分母。X3如果处于被括号扩起来的，也就意味着可以放到分子上。也就是说：X1/(X2/X3/../Xn) = (X1 *X3 *..*Xn)/X2
此题解的另一个启发：res如果要回退，那么不如在之前输出的时候，建立一个副本，让其不影响后面，后面也就无需考虑回退了。
### 73. Set Matrix Zeroes
**题意**：如果矩阵里有一个数为0，那么他所在的行列都清零。要求是空间复杂度为O（1）。

**解**：此题的困难之处是：如果修改0，那么会修改影响其他位置的值。
此题保持O（1）空间的技巧就是，利用第一列和第一行的空间来标记该行和列是否要被清空，然后只要先使用两个bool来分别保存第一列和第一行是否该被清空，然后在最后把第一列，第一行清空。
### 396. Rotate Function
**题意**：F函数等于B的下标乘以B数组的值的和。数组B每次循环右移一位。求所有的F函数中最大的那个。

**解**：这是数学题。如果使用暴力求解，那么每次移动是O（n）时间，也就是计算一次F需要O（n）时间，所以计算所有的F的总时间是O（n^2）。而使用数学技巧，可以将时间复杂度降到O（n）。如何做到的呢？大致思路就是F和上一项F之间存在公式关系，且该公式只需要消耗O（1）时间。
以Fk - Fk-1为例：计算的关键在于理解Bk-1[0]=Bk[1], Bk-1[1]=Bk[2]...这样计算出来Fk - Fk-1 = sum - nBk[0]。
这样只需要两边循环就可以求解，第一遍计算sum和F0，第二遍利用公式来递推F，保存其中的最大值即可。
### 13. Roman to Integer
**题意**：罗马数字转整数。

**解**:罗马数字特殊计数进制不是固定一个进制的，而是按1，5，50，100，500，1000来计算。靠近大整数的整数喜欢用后面整数，然后在前面加数字表示减去。
所以解法是，先加上每个字母对应数字，如果该字母比前一个字母大，那么减去前面的双倍即可。
### 28. Implement strStr()
**题意**：实现子串匹配。

**解**：经典算法是KMP。但是如果想简单实现，可以使用n方的方法。求解的过程中加入优化，就可以减少时间消耗。考虑母串，所有可能的解就是，从下标0开始的直到母串长度减去子串长度的下标。然后匹配过程中只要一个失配，那么马上进入下一个下标。
KMP：先根据子串构建next数组，然后在匹配过程中，一旦失配，那么子串根据next数组跳到相应的下标，继续匹配。
### 306. Additive Number
**题意**：AdditiveNum是指："112358" = {1, 1, 2, 3, 5, 8}； "199100199" = {1, 99, 100, 199}。
检验否是这样的数。

**解**：一开始以为是动态规划。但是不是。此题解题关键在于三点：1.只要确定了前两个数，那么就可以知道整个串基于这两个数是否可以为Additive Number。2.要以长度为限制来遍历前两个数，这样比双指针要好操作的多。3.第一个的长度限制是i <= len / 2; 第二个长度限制是 size - i - j >= max(i, j)。这是因为第三个数的长度一定不小于前两个数长度中最大的那个。
注意：number是long long型的，int不够用。
### 348. Design Tic-Tac-Toe
**题意**：判断Tic-Tac-Toe游戏每一步之后的输赢。输入保证有效。

**解**：每一步只需要O（1）时间判断输赢。方法如下：玩家1下的被标记为1，玩家2下的被标记为-1。对每列每行都维持一个数，代表总和。那么我们知道，当总和的绝对值等于行列大小的时候，说明玩家1或玩家2占满了这一行（列）。同理在对正反对角线都维持一个标记，表面对角线是否被占满。对当前一步下的棋，如果当前行列和两条对角线之中有一个满了，那么就说明赢棋。
### 567. Permutation in String
**题意**：给出串s1和串s2，判断s1的一种排列是不是可以是s2的子串。

**解**：方法一：28题的解法+给每次扫描时候，看第一个串和第二个串的一部分hash数组是否相等。
方法二：使用双指针，维持一个s1串大小的窗口，看n个s1串大小的窗口是不是hash值和s1串的hash值一样。
### 165. Compare Version Numbers
**题意**：比较版本号之间的大小。

**解**：此题的坑在于：1.0和1版本一致。那么按.切分数字的时候，空要被当做0来算,也就是说1和1.0.0.1来比较，其实是把之前的1看做是1.0.0.0。所以循环选两个长度中大的，在另一个越界的时候，全当作0来处理。
### 419. Battleships in a Board
**题意**：2D棋盘上，一行或一列（不一定满）的被称作战船，而且题目保证战船之间至少有一格间隙，也就是说不会出现不合法的战船。要求的是战船的数量。

**解**：此题一开始以为是BFS。后来发现并不是。只需要按照从左到右，从上到下的顺序扫描一遍棋盘即可。一旦是X，那么看他的左边或者上边是否也是X，如果是说明重复计算了，该点不用考虑了。如果不是，则结果加1。
### 54. Spiral Matrix
**题意**：螺旋顺序打印出矩阵中的数。

**解**：此题可以使用DFS，不过也可以直接循环求解。方法是：维持四个指针，指向行列的两头。然后每轮安排四个方向的扫描。首先沿着行头从左向右访问，访问之后行头指针加1，然后沿着列尾从上到下访问，访问之后列尾指针减1。然后沿着行尾从向右向左访问，如果行头仍然小于等于行尾的话；最后是沿着行头从下向上访问，如果列头仍然小于等于列尾的话。循环得出结果。
也可以使用dfs，保持四个方向，每次吃掉一个方向，把吃掉的点、也就是已经处理的点进行标记，防止重复访问，然后每次吃不动的时候，就切换到下一个方向继续。
### 722. Remove Comments
**题意**：删除代码里面的注释。给出的是按行分割的代码。如果是\/\*\*/注释，那么后面行的内容将被处理成一行。

**解**：迭代，分两种注释进行处理，\/\*\*/注释，后面行的内容将被处理成一行。取出每一个单词，取出当前单词处于非注释状态下的部分，然后看当前单词会不会产生新的注释，或者在已经注释状态下，会不会产生结束注释。
### 245. Shortest Word Distance III
**题意**：此题并非是244的follow up，而是最初始题目的follow up，也就是说不需要多次计算，计算最近单词的下标距离，唯一区别是输入可以是两个相等的单词，当然，相同时候结果不是0，而是两个实际存在的单词之间的距离。

**解**：此题循环中分两种情况处理，一种是搜索不同单词，和原题一样的解。另一种是相等，那么定义一个prev，只要prev不为初始值-1的时候，就将当前值减prev看能否更新最小值。
解法精髓就是，从左向右扫描，每次看能不能更新两个单词之间的差距，也就是说，每次更新记录遇到单词的最靠右的下标。
### 311. Sparse Matrix Multiplication
**题意**：给两个稀疏矩阵，求乘积。

**解**：只需一个三重循环就可以，因为第一个矩阵的列可以作为第二个矩阵的行。计算的时候，不要一次把一个数计算出来，而是利用该数所在的位置，对两个矩阵遍历的值进行累加。还要注意的是：由于是稀疏矩阵，那么在判断出不需要计算乘法的时候，可以省去一轮的循环，节省很多时间。第一个矩阵中的元素(i,j)，对最终矩阵元素的贡献在于最终矩阵第i行每个元素里面都包含(i, j)和第二个矩阵第j行的乘积，也就是说如果(i,j)所在元素为0，那么可以省去该次贡献的循环。
PS.稀疏矩阵有一个常见的压缩算法，那就是http://www.cs.cmu.edu/~scandal/cacm/node9.html
大致思想就是：稀疏矩阵转为邻接表。（0，0）的位置不需要了，每行只需要保留有值部分的下标和值，(index, val)对就可以了。
这样压缩之后，可以方便的对一行进行点乘，例如和一个vector<int>进行乘积，找到对应下标进行乘，然后累加就可以了。对同样的压缩方式的数组进行点乘也可以，使用双指针就可以了。
### 835. Image Overlap
**题意**：两个图片（矩阵0，1），移动两个图片，求最大的相交的1。

**解**：此题暴力求解就是计算AB两个图片之间的相对位置，然后对相交部分进行双循环计算重合的1，这样时间复杂度是O(n^4)。
但是此题可以使用311稀疏矩阵的解法来进行优化。对于每一个相对位置delta，不一定要计算重合部分，而是在整个的O(n^4)的循环过程中，零星的累加记录不同delta里面重合1的个数。这样好处是在背景图片像素点为0的时候跳过一个双重循环。
整个四层循环的目的就是计算两两坐标之间所有delta的距离是不是1（如果两个坐标所在值都为1，那么才为1， 如果有一个为0，那么就为0，0也就是零星计算时候跳过双重循环的关键），delta的计算就是坐标之间的差值，delta_x = i2 - i1, delta_y = j2 - j2。delta可能为负数，但是可以之前就全部加上n来平移。
### 277. Find the Celebrity
**题意**：找名人，名人就是一个人不认识其他任何人，而被其他人所认识。名人有就只能有一个。

**解**：暴力求解就是一个二重循环，每个人做不成名人的条件就是：他认识其他任何人中的一个，或者有一个人不认识他。
优化成O(n)的解法就是：首先要知道，名人只可能有一个。发现这种有向图中，只可能有一个结点是没有出边的，其他点都是存在出边的。
首先，先将0作为候选人，然后从1开始循环到n-1，将被认识的人更新当作候选人，因为候选人不认识的人做不成名人，与此同时，之前的候选者必然不是候选人，因为他们至少认识一个人。
第二步，再次循环一遍，判断该候选人是否是真的名人。名人必然是不认识其他人和被其他人认识的。第一步无法保证候选人不认识任何一个其他人以及其他人都认识他，也就是说，第一步做的其实是一个粗糙的排除法。
此题本质是有向图，找出有向图的没有出边的点。
### 14. Longest Common Prefix
**题意**：一个字符串数组，求最长公共前缀。

**解**：暴力求解，对于第一个字符串作为基点，遍历后面的串，一旦出现不匹配，或者下标越界，那么立即返回第一个字符串0到当前下标的子串。 
### 161. One Edit Distance
**题意**：判断字符串s和t是不是一个编辑距离。

**解**：所谓一个编辑距离有两种情况：（1）s和t长度相等，只有一个字符不同
（2）s和t之间长度相差1，多出来的那个元素可以在字符串的任何位置，剩余字符串元素必须一一相等对应。
其余情况都要返回false，只有满足（1）或（2）的才能返回true。
此题解的时候可以分情况去写，但是有一些节省循环代码的优化：关键是先找到s和t第一个不等的元素，如果是情况（1），那么剩余的子串要相等，否则返回false；如果是情况（2），那么长的一个去除当前不等元素开始到结尾的子串应该和短的不去除当前元素到结尾的子串相等，否则返回false。
如果找不到不相等的元素，那么看二者长度相差是否为1，为1就是true，否则为false。
PS.使用c++要注意，字符串的length取出来是无符号数，进行减法计算前要强制转换为带符号的类型。
abcd和acd也属于one edit，在b和c失配的时候，要比较cd和cd，也就是较长的串直接跳过失配字符，短串仍然需要考虑失配字符。
还有一个坑就是s等于t的时候，是不算只有一个距离的，应该返回false。
### 43. Multiply Strings
**题意**：实现字符串的乘法。假设俩串为s和t

**解**：关键是要在乘法的解法中找规律。对简单的示例（例如s =“123”，t = ”45“）进行观察，首先，总的结果长度不会超过s+t（理解：即使是99*99，那么也是小于10000的）。这样，首先设置总的结果存放的数组，初始时候每位都为0.
其次，列出发现s下标i和t下标j乘法后的规律：就是只会对结果数组的第i+j和i+j+1的下标进行影响。接下来要考虑乘法计算内部相加的顺序，发现对i+j位的影响是不可能变成0然后对i+j-1位造成进位的，理解：例如9*9 = 81。从右向左计算的时候，即使81的1变成0，进位，那么也只可能是8变9，而不会变成0进位给i+j-1。所以对i+j+1位要考虑进位，对i+j位则是直接加等就好。
计算顺序的技巧，记住即可：双重的for循环，每个循环都从右向左进行计算。
计算结束后，记得要把结果数组中的前面的0去掉,如果是全0，那么直接返回0。
### 88. Merge Sorted Array
**题意**：大意是把num2数组合并到num1数组里面去。

**解**：此题题意是num1的空间足够大。所以解的时候，肯定是不可以使用额外空间的。所以此题要想办法利用num1的空间。方法就是，从后往前合并，因为num1后面的空间是可以用的。
### 57. Insert Interval
**题意**：给出一些区间数组，然后在给一个区间t，求把该区间合并到之前区间中。原始区间已经按照头排好序。

**解**：被t影响后，原来数组会更新一个区间，关键是找到新区间的头和尾。
新区间的头是扫描数组区间的时候看哪个区间的尾大于新区间的头，找到第一个该区间后，看该区间的头与t的头哪个小，返回其中小的作为新区间的头。
新区间的尾是扫描数组区间，看哪个区间的头大于t的尾，此时说明当前区间以及之后的区间和新区间没关系了。此时再看之前一个区间的结尾和t的结尾哪个大，选择大的作为新区间的尾。
边界情况：第一，如果是t区间很小，不跨越任何区间，那么发现不受影响。
第二，如果t区间出现在所有区间的前面，那么新区间的头判断没问题，尾判断可能会遇到没有之前区间的问题。此时要看t区间的尾和第一个区间的头，来判断新区间的尾，更巧妙的方法是将新区间的尾初始化为第一个区间的头。
第三，如果t区间出现在所有区间后面，那么找不到比t尾大的区间头，此时如果是t区间的头比最后一个区间的头大，那么只需要直接把t区间加入，反之新区间的尾是t的尾。
程序过程：首先，扫描，如果区间end小于t的start，那么加入区间结果。扫描后，看是不是后面没有区间了，如果没有区间了，说明出现了边界情况3，这时把t加入结果，返回就可以了。如果不是，那么看当前区间的start和t的start相比，小的作为新区间的头。
接着扫描，这次看每个区间的开头，如果开头小于t的结尾，说明这些区间都可以被合并到新区间，因此接着扫描并更新最新的end，直到出现区间的开头小于t的结尾，跳出此次扫描，然后把最新合并的区间放入结果。此时，如果没有区间了，说明是边界条件3，直接返回就行了。否则，继续扫描后续区间，此时后面区间与前面区间无关了，只需要加入结果就可以了。
### 68. Text Justification
**题意**：给出单词数组和每行长度，现在要求把单词按顺序按行排列，要求左右对齐。

**解**：此题解法就是双指针字符串操作，双指针的窗口就是left指向的单词和right指向的单词能够放一行最大数，然后在安排单词之间的间隔数，即计算每个间隔的空格数。
每行计算出该有的单词数之后，分三种情况，第一种，单词数量大于1，那么得计算间隔数，以及余数，来填充单词间空格。
第二种，只有一个单词，那么加入单词后，后面全部填入空格。
第三种，数组中没有单词了，那么说明这一行填不满，这种情况下也当作只有一个单词来处理。
### 498. Diagonal Traverse
**题意**：按对角线来打印矩阵，扫描顺序是交替变化的。

**解**：此题一开始想使用模拟遍历法，发现遇到边角的时候，很难处理边界情况，例如矩阵[(1,2),(3,4)]中，遇到2，下一个访问的应该是3，但是对于一个奇数的矩阵[(1,2,3),(4,5,6),(7,8,9)]来说，遍历到右上角的3的时候，下一个访问的是6。这种边界条件难以区分。
现在考虑另一种做法：可以知道，此题相当于矩阵对角线遍历的follow up。对角线的遍历，是先从第一列的列头开始向右上方遍历，然后是最后一行的第二个元素开始向右上方遍历，这样，一旦走出矩阵，那么当前层的遍历就结束了。
所以，此题可以利用这样的方法，唯一的区别在于，交替的时候方向发生变化。
也就是说，如果是偶数层的时候，使用反方向的遍历就可以了。不过反向时候要新方法找起点。
另外，此题需要先将结果数组大小确定出来，然后更新相应下标就可以了，如果使用边遍历边记录的话，太耗费时间在数组增长上了。
两个关键：一个是对对角线进行标记，第0条，第1条，...第i条
另一个是对角线上的点(x, y)满足一个性质：x + y == i。
### 463. Island Perimeter
**题意**：求二维矩阵小岛的周长。

**解**：直接判断，方法一：扫描所有格子，如果是1，那么看该格子的四周的格子，如果出界了，或者是水的话（等于0），就加1。
方法二：遇到为1的，就加4，然后，看左边和上边的格子，如果是1，说明共边，那么结果减去2。
推荐方法一。
### 763. Partition Labels
**题意**：给出一个串S，尽可能多的分为子串，子串内字符可以重复，但是子串之间的字符不重复，要求返回各个子串大小。

**解**：此题看起来比较难，但是如果能够观察一个实例，就会发现，此题本质是区间题，每个字符在串S中的最左和最右下标代表了字符的作用范围。首先就扫描一遍串S，使用hashmap记录下每个字符的在串S中出现的开头和结尾下标。然后我们再扫描串S，对于每个出现的字符，看做是区间的覆盖问题，显然，只有出现字符的起始下标大于之前区间的结尾下标，才会新加区间，否则，贪心的不需要加区间。这样就能得出结果。
可以继续优化，不需要保存区间的起始点，只需要记录每个字符在串S中出现的最右下标，每次更新时候，把前一次的最右下标作为起始下标即可, 加入新区间的时机是当前扫描下标和当前字母对应下标一致的时候。
### 758. Bold Words in String
**题意**：给出单词数组和一个字符串s，现在要把s中出现的单词给加粗，也就是给开头结尾加上</b>标签。要求使用最少的标签字符。

**解**：此题方法多样。
方法一：建立s对应的标记数组，标记下标所在之处的单词是否要加粗。
接下来就是，建立函数，传入一个单词并在s中搜索，把能够找到的单词部分全部打上标记。
这样对单词数组中每个独一无二的单词调用一次函数后，就可以计算出标记数组。
最后，根据标记数组来构建新的结果字符串。遇到true的时候，先加入<b>，然后，跳过之后连续的true，然后加入</b>。再次遇到新的true的时候，继续加入<b>，依次类推，得出最终答案。具体一种字符串操作的技巧是：如果遇到的true之前并不是true，或者之前的越界了，那么说明是<b>开头，如果遇到的true之后的并不是true或者之后的越界了，那么说明该放入</b>。
### 616. Add Bold Tag in String
**题意**：给出串S和单词字典，现在要把S中的单词子串加粗，如果单词有重叠，那么把整个重叠部分加粗。

**解**：此题和758题一模一样。关键在于求单词重叠部分，如果是先找出所有单词的开始和结束，那么此题和merge interval一模一样。此题还可以使用另外一种解法：使用一个bool标记数组，标记S串每个下标所在元素是否应该被加粗，那么只要从头扫描S，对每个字符看看有没有以自己开头的单词（java用startwith， c++用substr + word的长度），然后就是看能不能更新最新的end（end表示从当前到end都应该标记为true，end是一个外部变量），如果最新的end比当前值大，那么应该覆盖。
### 448. Find All Numbers Disappeared in an Array
**题意**：数组里存的是下标范围内的数，一种元素只出现两次或一次。现在求下标中缺失的数（不止一个）。

**解**：数组里存的数减1后就真正满足了下标，所以，将该数（取绝对值）对应下标处的数字变为负数，如果本来是负数了，那么不变。最终在扫描一遍数组，如果数不是负数，那么说明原数组中该下标对应的数不存在。这种技巧使得空间复杂度变为O(1)。一开始使用hashmap，空间复杂度是O(n)。
### 280. Wiggle Sort
**题意**：将数组变为nums[0] <= nums[1] >= nums[2] <= nums[3]…

**解**：此题题意就是让奇数位置大于等于偶数位置的数。
采用交换的方式，O（N）的时间解决问题。思路就是：如果当前位处理的是奇数位置，那么他一定要大于等于之前的元素，如果小，那么与之前元素进行交换。如果当前处理的是偶数位置，那么一定要比之前的小于等于，否则与之前元素进行交换。我们从下标1开始处理，看看会不会出现反例，一开始是1和0位置进行比较，我们知道比较交换后，一定能够做到nums[0] <= nums[1]，然后看2的位置，如果2的位置比1的位置大，那么交换1和2之后会不会对之前的0产生影响呢？答案是不会，如果交换1和2，那么肯定是nums[1] < nums[2]，而之前nums[0] <= nums[1]，所以nums[2] 一定大于等于nums[0]，并不违反规律。同理，在看nums3，如果要交换2和3，那么nums[2] 一定大于等于nums[3]，所以nums[3]一定小于等于nums1。
所以，满足循环不变式，这样一直处理就可以得出答案。
### 324. Wiggle Sort II
**题意**：修改一个无序数组，使得满足nums[0] < nums[1] > nums[2] < nums[3]…

**解**：此题在也不具备第一题的解法性质了。
此题的O(nlogn)的解法是先排序，然后按中位数：
（1）奇数位置0开始从左到右放比中位数大的数（后半段）
（2）偶数位置size-1开始从右到左放比中位数小的数（前半段）
（3）中位数放第0位或最后一位
方法二：时间复杂度O(n)，空间复杂度O(1)。
使用下标映射，首先使用库函数nth_element找出median。使用库函数的好处是时间复杂度是平均O(N)的。而且，找出median后，数组会被自动分成两个部分，第一个部分数全部大于median，后半部分都小于median。例如  0 1 2 3 4 5 6 7, 其中4位置是median，那么0到3指向的数大于median，5到7指向的数都小于median。现在要做的就是把前面部分填入0 2 4 6的位置，而把后面的数填入1 3 5的位置， 最后7的位置放median。
这样，所要做的就是把所在下标与计算后的下标所在元素进行交换即可。由于不是两两交换的，还是要使用其他技巧。现在我们知道访问0下标的时候，其实我们访问的是我们关心的第一个奇数位，访问7的时候，其实访问的是我们关心的最后一个偶数位，那么简单了，保持一个扫描指针cur从头开始访问，如果发现其映射后当前下标所在数是比median大的话，那么与0指向的第一个奇数位交换，否则与7指向的最后一个偶数位进行交换。相当于说扫描cur就作为了保存临时结果。
实际上，对新映射位置的处理相当于彩虹排序。其中下标映射的公式为 (1 + 2*i) % (n | 1)。其中n或1是表示把n补成奇数。
### 370. Range Addition
**题意**：给出一个长度为n的全0数组，然后给出k个区间，以及每个区间需要自增的大小，求更新后的数组。

**解**：此题如果是暴力求解，那么时间复杂度为O(n * k)，因为在最坏情况下，每个区间的大小和数组一样大。
此题技巧性的解可以做到O(n + k)。做法就是，先在原数组中标记每个区间的开始和结尾，在开始的地方自增inc，然后在区间结束下标的下一个下标（如果有）自增-inc。然后从头到尾扫描一遍，每次元素加上之前元素就可以了。
此题类似于各种区间类问题。
### 809. Expressive Words
**题意**：给出一个串S和单词集合，然后看单词能不能扩展成串，扩展机制是：必须要是3个以上的字母才能扩展，比如hello不能由helo扩展得到，而helllo可以由helo扩展得到。

**解**：此题一开始以为是hash，但是hash是不对的，因为此题单词的顺序是重要的。所以此题的解题思路是：先把S串压缩，例如heeellooo，那么我们有h : 1, e : 3, l : 2, o : 3，然后在把单词压缩，例如helo，h:1,e:1,l:1,o:1。我们知道，首先，字母顺序一定要一一对应，否则无法扩展，其次，我们看S串字母对应的数字，如果小于单词的字母对应的数字，那么无法扩展；如果可以，接下来看S串字母对应的数字是不是大于3，大于的话就可以，否则看S串字母对应的数字是否和单词的字母对应的数字是否相等，如果不等，那么无法扩展。
编程时候注意一个细节：如果压缩后的两个串长度不等，那么说明无法扩展，直接返回。
### 777. Swap Adjacent in LR String
**题意**:RX变XR, XL变LX，现在求start串能不能唯一的变为end串。

**解**：此题不能bfs暴力解，而是采用观察规律的方法。此题去掉X之后的start串和end串必须一样。另外，我们比较下去掉X的start串和end串：RXXLRXRXL    => XRLXXRRLX
RX变成XR意味着end串中R一定出现在原来start串R的右边，反之，XL变成LX意味着end串中的L一定出现在原来start串L的左边。这一个性质要在串的任何位置得到满足，也就是说，从左向右扫描串，期间要保证start串里面R个数要严格小于等于end串，而start串L的个数要严格大于等于end串。
### 816. Ambiguous Coordinates
**题意**: 大意是，给出一个串S，求将串切分为坐标(x, y)的所有情况，其中坐标内部可以加上“.”构造小数。当然也存在不合法的情况：例如0.0，00，001，00.01都是不合法的情况。
**解**：暴力求解，先从第i（1 <= i <= n - 1）个位置考虑把S断成两个部分A和B，然后每个部分内部在考虑使用“.”来进行分割，返回的两个集合在进行组合，就可以得出一个位置切分后的答案。
判断A、B不合法的情况：首先，如果串A大小为0，那么不合法，或者A的大小大于0，但是A同时以0开头和结尾，那么也不合法。如果是以0开头，那么唯一的合法形式就是0.xxxx。如果是以0结尾，那么唯一合法形式就是不加“.”的串本身。此外就是从1到i-1都能加“.”以及串本身的情况。
PS.原来的串是带有()的。
### 769. Max Chunks To Make Sorted
**题意**：给出0到n-1的排列，问需要分成多少组，然后组内排序（不是翻转）之后，最后总体排列还原成0到n-1的有序情况。例如4，3，2，1，0变成0，1，2，3，4只能是分一组排序。

**解**：观察规律，4出现在第0位，意味着第0位到最后一位必须作为一组了，不然无法满足条件。同理，0出现在第n-1位，那么意味着第0到第n-1位必须作为一组。这两种考虑是等价的。
假设就从元素最终所在的位置的左侧进行考虑：4出现在第0位，不考虑后面3，2，1，0的位置，由于4最终一定出现在下标为4的位置，所以对于4的分组一定会包含3，也就是3的考虑被4的情况给覆盖了。
所以，此题又可以与区间问题关联起来，例如串3，4，0，1，2。我们看第一个3的时候，对3的理解变为它的覆盖范围是下标区间[0, 3]，也就是{3,4,0,1}。而后面4的作用范围是[1, 4]。我们发现两个下标区间是重叠的，对于最终答案，我们发现结果是1，也就是意味着此题转化为求[0, n -1]会出现多少个独立的小区间,和大楼轮廓问题有一些相似之处，可以覆盖的范围就是高度。
所以，此题的一种解法就是扫描，记录当前元素的从当前下标开始的区间的覆盖范围的当前最大值，（1）如果扫描下标比当前最大值小，意味着当前下标是被最大值所在区间给覆盖住的，也就不计入结果。（2）会不会出现当前下标大于最大值呢？也就是说最大值覆盖不到当前下标呢？不存在的，即使严格按照升序来排也做不到。（3）当前下标等于最大值，意味着之前最大值的覆盖范围在此处消失，此时对结果数加1，也就是说之前的区间是一个独立的区间。
最大值进行更新意味着什么？如果之前最大值覆盖范围已经消失，意味着新区间的开始，如果之前最大值覆盖范围还没有消失，意味着出现区间重叠（此时区间数不变），也就好比是一个楼被后面的高楼给覆盖了。
### 163. Missing Ranges
**题意**：给出上下界，再给出若干数，现在求数之间的区间。

**解**：此题处理上下界的方法必须独特，给出几个例子：一个是元素等于上界的情况：[-1]在下界为-2，上界为-1的情况下，答案是{[-2]}。做法是扫描，如果发现lower与当前扫描元素有差距0以上，那么就把差距区间记录到答案中，然后lower更新为扫描元素大小+1。扫描完之后，在对lower和上限做最后的处理。
最后还要注意元素+1会导致整数越界的情况，所以统一使用long型。
### 766. Toeplitz Matrix
**题意**：验证一个矩阵是不是Toeplitz矩阵，也就是左上到右下的对角线元素全都相同。

**解**：此题思路是带有方向的矩阵遍历，也就是说：下一步该访问的格子可以通过方向计算得出，接下来就是确定所有出发的格子，此题中第一行和第一列是出发的格子。然后全部验证完就可以。
还有一种解题方式是混合遍历，也就是说，每次扫描的不一定和上面有关，但是是与之前处理过的部分有关，这样即使依次访问的格子之间没有直接依赖，但是还是可以正确的得出答案，而且代码更简洁。
### 859. Buddy Strings
**题意**：给出串A和串B，问串A是不是有且只能交换一次元素来达到B。

**解**：理解题意的关键：串A是必须交换一次的，所以"ab"和"ab"返回false，而“aa”和“aa”是返回true的， “aba”和“aba”也是返回true的。
理解题意，举出各种例子之后，才开始构思编程。
先找规律，发现，如果两串相同位置出现相同字符，且字符重复了，剩余位置字符相同，那么一定是返回true的。然后就会发现，两串其实是相等的，也就是说AB相等条件下，必须要包含重复字符才能满足要求。
不等的情况，就按照A，B差一个字符方式来调整。
不能多于一个位置不同。
“ab”和“ab”返回false，因为交换一次后不等，"aab"和"aab"就返回true，因为可以第一个'a'和第二个'a'交换。
### 821. Shortest Distance to a Character
**题意**：给出串S和字符c，求出串S所有字符离自己最近的字符c的距离。

**解**：此题是wall and gates的简化版，使用并行的bfs层序遍历就可以解。
还有一种是字符串处理的思路：可以从左向右扫描一遍，看每个字符离自己最近的C的距离，如果不存在，那么先把最近的C的距离定义为比串S长度负数还要小的数，这样后面无论是否出现C就一定可以使得最小为串S长度。
在从右向左扫描一遍，取较小值。
### 647. Palindromic Substrings
**题意**：求substring里面，回文串的个数。

**解**：对于求substring是否回文串的题目，起点是每一个元素以及一对元素当作回文串的中心，并做两种情况考虑：（1）该元素是是奇串的中心；（2）该元素是偶串的中心对的第一个元素。然后每次向两边方向，每次取两个元素进行观察，看是否能扩充当前的串。
此题是对每一个位置作为中心进行考虑，看能扩充多少个回文串。这样考虑的好处就是，如果发现不能扩充了，那么后面的也不可能作回文串了，而发现可以扩充，那就是找到了以当前坐标为中心的新的一个回文串。
### 334. Increasing Triplet Subsequence
**题意**：看未排序的数组中是否存在三个递增的元素序列（不需要连续）。

**解**：此题一开始以为是求最长子序列的动态规划题目，但是该方法消耗时间O(n^2)，并不能通过。
此题其实只需要扫描一遍就能知道是否存在这样的三元组。思想还是动态规划，对于当前扫描过的结点中，我们记录下最小结点，然后在扫描新结点的过程中，我们看是否存在比最小值大的结点，如果存在，那么可以作为三元组中的第二个元素进行考虑，如果当前扫描过的序列中存在（最小值，第二个元素）这两个要点，那么如果在碰到一个比第二个元素大的，那么返回true。
如果新扫描的点nums[i]比最小值小，那么更新最小值，不必更新第二个元素，因为之前序列0~i-1就存在（旧最小值，第二小的元素）这样的候选者。如果下一个元素大于第二个元素(都不用考虑最小值被更新了，只需要知道存在第二小的元素)，那么仍然可以返回true，如果下一个元素介于新最小值和第二个元素之间，那么可以更新第二个元素，组成新的候选者：（新最小值，新第二个元素）。
还有一种方法，是在O(N)时间计算i左侧的最小值：dp[i] = min{dp[i-1], nums[i]}，然后在扫描一遍求出i到n区间的最大值，这样，最后再扫描一遍，看nums[i]是否比左边最小值大，是否比右边最大值小。
